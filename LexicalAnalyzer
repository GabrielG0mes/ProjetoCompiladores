package Compilador;
import java.io.IOException;
import java.io.Reader;

/**
 * Links utilizados para a realização do trabalho:
-http://jflex.de/
-https://johnidm.gitbooks.io/compiladores-para-humanos/content/part1/lexical-analysis.html
 * @authors Gabriel & Nayara
 */

    public class LexicalAnalyzer {
    /**
     * Tamanho do buffer. Variável depende do tamanho do texto digitado. Se for muito grande, deve-se colocar um número maior.
     */
    private static final int BUFFERSIZE = 500;
     /**
     * Mapa de caracteres. Obs: Não destrinchamos, pois ficaria muito grande. O
     * vetor resultante contém mais de 1 milhão de índices. Aqui é onde o caracter é buscado.
     */
     
    private static final String CHARMAP_PACKED
            = "\11\0\1\1\1\1\1\27\1\27\1\1\22\0\1\1\1\0\1\13"
            + "\5\0\1\14\1\14\1\10\1\6\1\0\1\7\1\0\1\11\1\12"
            + "\11\4\1\0\1\14\1\0\1\5\3\0\32\2\4\0\1\2\1\0"
            + "\3\2\1\25\1\24\1\16\1\2\1\22\1\15\2\2\1\23\2\2"
            + "\1\17\2\2\1\20\1\26\3\2\1\21\3\2\1\14\1\3\1\14"
            + "\7\0\1\27\u1fa2\0\1\27\1\27\uffff\0\uffff\0"
            + "\uffff\0\uffff\0\uffff\0\uffff\0\uffff\0\uffff"
            + "\0\uffff\0\uffff\0\uffff\0\uffff\0\uffff\0\uffff\0\uffff\0\uffff\0\udfe6\0";            
    /**
     * Vetor resultante do desempacotamento do mapa de caracteres.
     */
      private static final char[] CHARACTER_CMAP = zzUnpackCMap(CHARMAP_PACKED);
    /**
     * Traduz estado do AFD para ação do switch.
     */
     
     private static final int[] ACTION = {0, 1, 2, 3, 2, 4, 5, 6, 7, 8, 9, 4, 1, 10,
        3, 3, 3, 3, 3, 0, 11, 3, 3, 3, 12, 13, 14, 3, 3, 3, 15, 16};
    /**
     * Traduz o estado para uma linha de índice na tabela de transição
     */
     
     private static final int[] ROWMAP = {0, 24, 24, 48, 48, 72, 24, 24, 24, 24,
        24, 24, 96, 24, 120, 144, 168, 192, 216, 240, 48, 264, 288, 312, 48, 24, 48, 336, 360, 384, 48, 48};
    /**
     * Determina que transição a máquina de estados fará.
     */     
      private static final int[] TRANSITIONS = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 3, 3, 16, 3, 3, 
        17, 18, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, 3, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, -1, -1, -1, 5, -1, 
        -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, 19, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, -1, -1, -1, 3, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 20, 
        3, 3, 3, 3, 3, 3, 3, 3, -1, -1, -1, 3, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 3, 21, 3, 3, 3, 3, 3, 3, 3, -1, 
        -1, -1, 3, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 3, 3, 3, 3, 22, 3, 3, 3, 3, -1, -1, -1, 3, 3, 3, -1, -1, -1, 
        -1, -1, 3, -1, -1, 3, 3, 3, 3, 3, 3, 23, 3, 3, 3, -1, -1, -1, 3, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 3, 24, 
        3, 3, 3, 3, 3, 3, 3, -1, -1, -1, 19, 19, 19, -1, -1, -1, -1, -1, 19, 25, -1, 19, 19, 19, 19, 19, 19, 19, 19, 19, 
        19, -1, -1, -1, 3, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 3, 3, 26, 3, 3, 3, 3, 3, 3, -1, -1, -1, 3, 3, 3, -1, 
        -1, -1, -1, -1, 3, -1, -1, 27, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, -1, 3, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 
        3, 3, 3, 3, 3, 3, 3, 3, 28, -1, -1, -1, 3, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 3, 3, 3, 3, 3, 29, 3, 3, 3, 
        -1, -1, -1, 3, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 3, 3, 3, 3, 3, 3, 30, 3, 3, -1, -1, -1, 3, 3, 3, -1, -1, 
        -1, -1, -1, 3, -1, -1, 3, 3, 3, 3, 3, 3, 3, 31, 3, 3, -1};
    /**
     * Contém os atributos do estado.
     */
     private static final int[] ATTRIBUTE = {0, 9, 9, 1, 1, 1, 9, 9, 9, 9, 9, 9, 1,
        9, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 9, 1, 1, 1, 1, 1, 1};
    /**
     * A string com o código a ser compilado, recebido do método main.
     */
      private final Reader reader;
    /**
     * Contém os caracteres do código a ser compilado.
     */
    private final char buffer[] = new char[BUFFERSIZE];
    /**
     * Variáveis para controle do scanning.
     */

    private int marked;
    private int current;
    private int startRead;
    private int endRead;
    private int state;

    private char[] buffer = new char[1000];

    private boolean eof;

    private Reader reader;

    public void GenerateLexemes() throws IOException {
        int input;
        int action;

        int currentL;
        int markedL;
        
        

        while (true) {
            markedL = marked;   //última posição aceita
            action = -1;
            currentL = current = start = markedL;
            state = 0;
            action:
            {
                
            }
        }
    }

    private void print(String descricao, String lexema) {
        System.out.println(lexema + " - " + descricao);
    }

    public final String text() {
        return new String(buffer, start, marked - start);
    }

    private boolean Fill() throws IOException {
        int numRead = reader.read(buffer, end, buffer.length - end);
        if (numRead > 0) {
            end += numRead;
            return false;
        }
        return true;
    }
}
