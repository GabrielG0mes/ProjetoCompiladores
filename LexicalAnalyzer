package Compilador;
import java.io.IOException;
import java.io.Reader;

/**
 * Links utilizados para a realização do trabalho:
-http://jflex.de/
-https://johnidm.gitbooks.io/compiladores-para-humanos/content/part1/lexical-analysis.html
 * @authors Gabriel & Nayara
 */

    public class LexicalAnalyzer {
    /**
     * Tamanho do buffer. Variável depende do tamanho do texto digitado. Se for muito grande, deve-se colocar um número maior.
     */
    private static final int BUFFERSIZE = 500;
     /**
     * Mapa de caracteres. Obs: Não destrinchamos, pois ficaria muito grande. O
     * vetor resultante contém mais de 1 milhão de índices. Aqui é onde o caracter é buscado.
     */
     
    private static final String CHARMAP_PACKED
            = "\11\0\1\1\1\1\1\27\1\27\1\1\22\0\1\1\1\0\1\13"
            + "\5\0\1\14\1\14\1\10\1\6\1\0\1\7\1\0\1\11\1\12"
            + "\11\4\1\0\1\14\1\0\1\5\3\0\32\2\4\0\1\2\1\0"
            + "\3\2\1\25\1\24\1\16\1\2\1\22\1\15\2\2\1\23\2\2"
            + "\1\17\2\2\1\20\1\26\3\2\1\21\3\2\1\14\1\3\1\14"
            + "\7\0\1\27\u1fa2\0\1\27\1\27\uffff\0\uffff\0"
            + "\uffff\0\uffff\0\uffff\0\uffff\0\uffff\0\uffff"
            + "\0\uffff\0\uffff\0\uffff\0\uffff\0\uffff\0\uffff\0\uffff\0\uffff\0\udfe6\0";            
    /**
     * Vetor resultante do desempacotamento do mapa de caracteres.
     */
      private static final char[] CHARACTER_CMAP = zzUnpackCMap(CHARMAP_PACKED);
    /**
     * Traduz estado do AFD para ação do switch.
     */
     
     private static final int[] ACTION = {0, 1, 2, 3, 2, 4, 5, 6, 7, 8, 9, 4, 1, 10,
        3, 3, 3, 3, 3, 0, 11, 3, 3, 3, 12, 13, 14, 3, 3, 3, 15, 16};
    /**
     * Traduz o estado para uma linha de índice na tabela de transição
     */
     
     private static final int[] ROWMAP = {0, 24, 24, 48, 48, 72, 24, 24, 24, 24,
        24, 24, 96, 24, 120, 144, 168, 192, 216, 240, 48, 264, 288, 312, 48, 24, 48, 336, 360, 384, 48, 48};
    /**
     * Determina que transição a máquina de estados fará.
     */     
      private static final int[] TRANSITIONS = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 3, 3, 16, 3, 3, 
        17, 18, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, 3, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, -1, -1, -1, 5, -1, 
        -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, 19, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, -1, -1, -1, 3, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 20, 
        3, 3, 3, 3, 3, 3, 3, 3, -1, -1, -1, 3, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 3, 21, 3, 3, 3, 3, 3, 3, 3, -1, 
        -1, -1, 3, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 3, 3, 3, 3, 22, 3, 3, 3, 3, -1, -1, -1, 3, 3, 3, -1, -1, -1, 
        -1, -1, 3, -1, -1, 3, 3, 3, 3, 3, 3, 23, 3, 3, 3, -1, -1, -1, 3, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 3, 24, 
        3, 3, 3, 3, 3, 3, 3, -1, -1, -1, 19, 19, 19, -1, -1, -1, -1, -1, 19, 25, -1, 19, 19, 19, 19, 19, 19, 19, 19, 19, 
        19, -1, -1, -1, 3, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 3, 3, 26, 3, 3, 3, 3, 3, 3, -1, -1, -1, 3, 3, 3, -1, 
        -1, -1, -1, -1, 3, -1, -1, 27, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, -1, 3, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 
        3, 3, 3, 3, 3, 3, 3, 3, 28, -1, -1, -1, 3, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 3, 3, 3, 3, 3, 29, 3, 3, 3, 
        -1, -1, -1, 3, 3, 3, -1, -1, -1, -1, -1, 3, -1, -1, 3, 3, 3, 3, 3, 3, 3, 30, 3, 3, -1, -1, -1, 3, 3, 3, -1, -1, 
        -1, -1, -1, 3, -1, -1, 3, 3, 3, 3, 3, 3, 3, 31, 3, 3, -1};
    /**
     * Contém os atributos do estado.
     */
     private static final int[] ATTRIBUTE = {0, 9, 9, 1, 1, 1, 9, 9, 9, 9, 9, 9, 1,
        9, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 9, 1, 1, 1, 1, 1, 1};
    /**
     * A string com o código a ser compilado, recebido do método main.
     */
      private final Reader reader;
    /**
     * Contém os caracteres do código a ser compilado.
     */
    private final char buffer[] = new char[BUFFERSIZE];
    /**
     * Variáveis para controle do scanning.
     */

    private int marked;
    private int current;
    private int startRead;
    private int endRead;
    private int state;
    /**
     * Indica o final da leitura do arquivo.
     */
    private boolean endOfFile;
    /**
     * Exibe 
     * @param descricao
     * @param lexema 
     */
    private void imprimir(String descricao, String lexema) {
        System.out.println(lexema + "\t\t\t- \t" + descricao);
    }
    /**
     * Construtor da classe. Recebe um java.io.Reader como parâmetro
     * @param reader 
     */
    LexicalAnalyzer(Reader reader) {
        this.reader = reader;
    }
    /**
     * Método para desempacotar o mapa de caracteres.
     * @param packed
     * @return 
     */
    private static char[] UnpackCMap(String packed) {
        char[] map = new char[0x110000];
        int i = 0;
        int j = 0;
        while (i < 144) {
            int count = packed.charAt(i++); 
            char value = packed.charAt(i++);
            do {
                map[j++] = value;
            } while (--count > 0);
        }
        return map;

    }
    /**
     * Método para preencher o buffer com os caracteres do reader.
     * @return
     * @throws IOException 
     */
    private boolean Refill() throws IOException {
        int numRead = reader.read(buffer, endRead, buffer.length - endRead);
        if (numRead > 0) {
            endRead += numRead;
            return false;
        }
        return true;
    }
    /**
     * Exibe a mensagem na tela.
     * @return 
     */
    public final String text() {
        String out = new String(buffer, startRead, marked - startRead);
        return out;
    }
    /**
     * Método gerador dos tokens.
     * @throws IOException 
     */
    public void tokens() throws IOException {
        int input;
        int action;
        int currentL;
        int markedL;
        while (true) {
            markedL = marked;
            action = -1;
            currentL = current = startRead = markedL;
            state = 0;
            action:
            {
                while (true) {
                    if (currentL < endRead) {
                        //Busca o caracter no buffer.
                        input = Character.codePointAt(buffer, currentL, endRead);
                        currentL += 1;
                    } else if (endOfFile) {
                        input = -1;
                        break action;
                    } else {
                        current = currentL;
                        marked = markedL;
                        boolean eof = Refill();
                        currentL = current;
                        markedL = marked;
                        //Indica o final da leitura do texto.
                        if (eof) {
                            input = -1;
                            break action;
                        } else {
                            input = Character.codePointAt(buffer, currentL, endRead);
                            currentL += 1;
                        }
                    }
                    
                    int next = TRANSITIONS[ROWMAP[state] + CHARACTER_CMAP[input]];
                    //Para cada espaço em branco encontrado, reinicia o action.
                    if (next == -1) {
                        break action;
                    }
                    state = next;
                    //Quando encontra um espaço em branco, muda para o próximo estado.
                    if ((ATTRIBUTE[state] & 1) == 1) {
                        action = state;
                        markedL = currentL;
                    }
                }
            }
            //Atualiza o ultimo caracter marcado para o proximo a ser lido.
            marked = markedL;

            if (input == -1 && startRead == current) {
                endOfFile = true;
                return;
            } else {
                switch (action < 0 ? action : ACTION[action]) {
                    case 1: {
                        throw new RuntimeException("Caractere inválido " + text());
                    }
                    case 17:
                        break;
                    case 2: {
                        imprimir("\tEspaço em branco", text());
                    }
                    case 18:
                        break;
                    case 3: {
                        imprimir("\tIdentificador", text());
                    }
                    case 19:
                        break;
                    case 4: {
                        imprimir("\tNúmero", text());
                    }
                    case 20:
                        break;
                    case 5: {
                        imprimir("\tOperador de atribuição", text());
                    }
                    case 21:
                        break;
                    case 6: {
                        imprimir("\tOperador de soma", text());
                    }
                    case 22:
                        break;
                    case 7: {
                        imprimir("\tOperador de subtração", text());
                    }
                    case 23:
                        break;
                    case 8: {
                        imprimir("\tOperador de multiplicação", text());
                    }
                    case 24:
                        break;
                    case 9: {
                        imprimir("\tOperador de divisão", text());
                    }
                    case 25:
                        break;
                    case 10: {
                        imprimir("\tSeparador", text());
                    }
                    case 26:
                        break;
                    case 11: {
                        imprimir("\tPalavra reservada if", text());
                    }
                    case 27:
                        break;
                    case 12: {
                        imprimir("\tPalavra reservada do", text());
                    }
                    case 28:
                        break;
                    case 13: {
                        imprimir("String", text());
                    }
                    case 29:
                        break;
                    case 14: {
                        imprimir("\tPalavra reservada for", text());
                    }
                    case 30:
                        break;
                    case 15: {
                        imprimir("\tPalavra reservada else", text());
                    }
                    case 31:
                        break;
                    case 16: {
                        imprimir("\tPalavra reservada while", text());
                    }
                    case 32:
                        break;
                    default:
                        System.out.println("Erro.");
                }
            }
        }
        
    }

}
